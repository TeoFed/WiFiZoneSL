{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".section {text-align:center;} UNIVERSIT\u00c0 DEGLI STUDI DI MILANO Relazione di progetto Reti di Calcolatori Una Wi-Fi Zone Free & Open Fedeli Matteo - 895687 - 21/08/2019","title":"Home"},{"location":"captivePortal/","text":"Social Login La funzionalit\u00e0 di Social login \u00e8 garantita generando un token temporaneo dopo che l'utente ha effettuato il login tramite Social. Questo tipo di implementazione permette di implementare il social login con un qualsiasi captive portal che supporta il protocollo RADIUS perch\u00e8 \u00e8 totalmente trasparente ad esso. Installazione di django-allauth: pip install django-allauth Assicurarsi che il file settings.py e come l'esempio seguente (Sar\u00e0 spiegato utilizzando facebook come esempio) INSTALLED_APPS = [ # ... other apps .. # apps needed for social login 'rest_framework.authtoken', 'django.contrib.sites', 'allauth', 'allauth.account', 'allauth.socialaccount', # showing facebook as an example # to configure social login with other social networks # refer to the django-allauth documentation 'allauth.socialaccount.providers.facebook', ] SITE_ID = 1 Al file urls.py va aggiunto anche il la seguente linea tra gli url urlpatterns = [ # .. other urls ... url(r'^accounts/', include('allauth.urls')), ] Facebook supporta sia OAuth2 che il Facebook Connect Javascript SDK. Un vantaggio dell'SDK di Javascript potrebbe essere un'esperienza utente pi\u00f9 ottimizzata poich\u00e9 non si esce dal sito. Inoltre, non \u00e8 necessario preoccuparsi di adattare la finestra di dialogo di accesso a seconda che si stia utilizzando o meno un dispositivo mobile. Tuttavia, fare affidamento su Javascript potrebbe non essere sempre la soluzione migliore. The following Facebook settings are available: SOCIALACCOUNT_PROVIDERS = { 'facebook': { 'METHOD': 'oauth2', 'SDK_URL': '//connect.facebook.net/{locale}/sdk.js', 'SCOPE': ['email', 'public_profile', 'user_friends'], 'AUTH_PARAMS': {'auth_type': 'reauthenticate'}, 'INIT_PARAMS': {'cookie': True}, 'FIELDS': [ 'id', 'email', 'name', 'first_name', 'last_name', 'verified', 'locale', 'timezone', 'link', 'gender', 'updated_time', ], 'EXCHANGE_TOKEN': True, 'LOCALE_FUNC': 'path.to.callable', 'VERIFIED_EMAIL': False, 'VERSION': 'v2.12', } } METHOD: js_sdk or oauth2. Di default \u00e8 oauth2. SDK_URL: se necessario, \u00e8 possibile utilizzare un SDK_URL per sovrascrivere il JavaScript Facebook URL SDK (//connect.facebook.net/{locale}/sdk.js) Questo pu\u00f2 essere per esempio necessario quando si decide di un plugin di chat clienti.Se SDK_URL contiene una stringa chiamata {locale} vuol dire che la funzione LOCALE_FUNC sar\u00e0 usata per generare SDK_URL. SCOPE: Per impostazione predefinita, l'ambito e-mail \u00e8 richiesto a seconda che SOCIALACCOUNT_QUERY_EMAIL sia abilitato o meno. Le app che utilizzano autorizzazioni oltre a e-mail, public_profile e user_friends richiedono la revisione da parte di Facebook. Vedi Autorizzazioni con Facebook Login per ulteriori informazioni. AUTH_PARAMS: Utilizzare AUTH_PARAMS per passare altri parametri alla chiamata SDK JS FB.login. FIELDS: I campi da recuperare dall'API Graph / me /? fields = endpoint. Ad esempio, potresti aggiungere il campo \"amici\" per catturare gli amici dell'utente che hanno effettuato l'accesso anche alla tua app tramite Facebook (richiede l'ambito \"user_friends\"). EXCHANGE_TOKEN: L'SDK JS restituisce un token di breve durata adatto all'uso lato client. Impostare EXCHANGE_TOKEN = True per effettuare una richiesta lato server per l'aggiornamento a un token di lunga durata prima di archiviare nel record SocialToken. LOCALE_FUNC: The locale for the JS SDK is chosen based on the current active language of the request, taking a best guess. This can be customized using the LOCALE_FUNC setting, which takes either a callable or a path to a callable. This callable must take exactly one argument, the request, and return a valid Facebook locale as a string, e.g. US English: SOCIALACCOUNT_PROVIDERS = { 'facebook': { 'LOCALE_FUNC': lambda request: 'en_US' } } VERIFIED_EMAIL: It is not clear from the Facebook documentation whether or not the fact that the account is verified implies that the e-mail address is verified as well. For example, verification could also be done by phone or credit card. To be on the safe side, the default is to treat e-mail addresses from Facebook as unverified. But, if you feel that is too paranoid, then use this setting to mark them as verified. Due to lack of an official statement from the side of Facebook, attempts have been made to reverse engineer the meaning of the verified flag. Do know that by setting this to True you may be introducing a security risk. VERSION: The Facebook Graph API version to use. The default is v2.12. App registration (get your key and secret here) A key and secret key can be obtained by creating an app. After registration you will need to make it available to the public. In order to do that your app first has to be reviewed by Facebook. Development callback URL Leave your App Domains empty and put http://localhost:8000 in the section labeled Website with Facebook Login. Note that you\u2019ll need to add your site\u2019s actual domain to this section once it goes live. Captive page button example Following the previous example configuration with facebook, in your captive page you will need an HTML button similar to the ones in the following examples. Log in with Facebook Substitute openwisp2.mywifiproject.com and captivepage.mywifiproject.com with the hostname of your django-freeradius instance and your captive page respectively.","title":"captivePortal"},{"location":"comp/","text":"Le componenti Per far fronte a tutte le nostre esigenze in modo scalabile, versatile, e sicuro \u00e8 stato scelto pfSense per garantire la sicurezza e gestire i DNS (tramite BIND9 ) cos\u00ec da avere per ogni servizio gli FQDN (talvolta obbligatoriamente) adeguati e oVirt come sistema di virtualizzazione per poterci installare tutte le VM necessarie. 2.1 OpenWisp OpenWISP \u00e8 un progetto nato per permettere una semplice gestione di rete e permettere l\u2019automazione sotto diversi aspetti come: Auto configurazione dei nodi Creazione di tunnel VPN Inizializzazione di access point WiFi in modo centralizzato Configurazione di reti mesh Configurazione di ogni rete supportata da OpenWRT L'applicazione server-side \u00e8 modulare, estensibile, programmabile e configurabile. I moduli sono sviluppati con Django, un ricco ecosistema di componenti riutilizzabili soprattutto per applicazioni di rete. Al momento solo OpenWRT \u00e8 completamente supportato per uso in produzione, ma in modo sperimentale \u00e8 disponibile anche il backend per Ubiquiti AirOS. Inoltre, l'engine permette la scrittura di configurazioni personalizzate su tutti gli OS di rete che supportano le configurazioni remote. Il sistema \u00e8 caratterizzato da due parti: OpenWISP Controller , motore che genera configurazioni per router e dispositivi di rete utilizzando Python e NetJSON. La gestione \u00e8 permessa grazie ad un interfaccia Web che permette la gestione della rete fornendo funzionalit\u00e0 di: Registrazione degli apparati automatica Mappe geografiche per posizionamento Indoor e Outdoor VPN e certificati x509 Topologia di rete RADIUS manager: django-freeradius IP & subnet administration: django-ipam Sistemi di controllo Aggiornamento Firmware OpenWRT package , pacchetto installabile su OpenWRT per permettere la sincronizzazione con il controller 2.2 OpenWRT Il progetto OpenWrt \u00e8 un sistema operativo Linux destinato a dispositivi embedeed. Invece di provare a creare un singolo firmware statico, OpenWrt fornisce un filesystem completamente scrivibile con gestione dei pacchetti. Questo libera dalla selezione e dalla configurazione dell'applicazione fornite dal venditore e consente di personalizzare il dispositivo attraverso l'uso di pacchetti per adattarsi a qualsiasi applicazione. Per gli sviluppatori, OpenWrt \u00e8 il framework per creare un'applicazione senza dover creare un firmware completo al suo interno; per gli utenti ci\u00f2 significa la possibilit\u00e0 di personalizzazione completa, permettendo di adattarlo secondo le proprie esigenze. OpenWRT ad oggi \u00e8 supportato da oltre 1000 device. Consultando il sito del progetto \u00e8 possibile verificarne la compatibilit\u00e0 e la procedura per sostituire il firmware stock. 2.3 FreeRADIUS FreeRADIUS \u00e8 la pi\u00f9 popolare implementazione open-source del protocollo RADIUS. Permette l\u2019autenticazione, l\u2019autorizzazzione e l\u2019accounting. Nel nostro caso a stretto contatto con django-freeradius autorizzer\u00e0 la navigazione ad internet dopo essere passati dal nostro captive portal. 2.4 Django-Freeradius E\u2019 un\u2019interfaccia web per gestire il database FreeRADIUS basata su Django. Necessaria per integrare le funzionalit\u00e0 di FreeRADIUS per poter gestire l\u2019autorizzazione, la post autenticazione e l\u2019accounting tramite API RESTful. Inoltre in questo caso \u00e8 necessario per permettere la verifica tramite social grazie all\u2019integrazione del modulo django-allauth. 2.5 CoovaChilli CoovaChilli \u00e8 un controller ricco di funzionalit\u00e0 che fornisce la possibilit\u00e0 di attivare un Captive Portal cos\u00ec da garantire l'accesso tramite protocollo RADIUS o HTTP permettendo l'access provisioning e l'accounting. Questo controller \u00e8 fruibile come package per Openwrt oppure \u00e8 parte integrante del firmware CoovaAP. Questo package sommato a Freeradius e Django-freeradius permetter\u00e0 di raggiungere il nostro obbiettivo.","title":"2. Le componenti"},{"location":"comp/#21-openwisp","text":"OpenWISP \u00e8 un progetto nato per permettere una semplice gestione di rete e permettere l\u2019automazione sotto diversi aspetti come: Auto configurazione dei nodi Creazione di tunnel VPN Inizializzazione di access point WiFi in modo centralizzato Configurazione di reti mesh Configurazione di ogni rete supportata da OpenWRT L'applicazione server-side \u00e8 modulare, estensibile, programmabile e configurabile. I moduli sono sviluppati con Django, un ricco ecosistema di componenti riutilizzabili soprattutto per applicazioni di rete. Al momento solo OpenWRT \u00e8 completamente supportato per uso in produzione, ma in modo sperimentale \u00e8 disponibile anche il backend per Ubiquiti AirOS. Inoltre, l'engine permette la scrittura di configurazioni personalizzate su tutti gli OS di rete che supportano le configurazioni remote. Il sistema \u00e8 caratterizzato da due parti: OpenWISP Controller , motore che genera configurazioni per router e dispositivi di rete utilizzando Python e NetJSON. La gestione \u00e8 permessa grazie ad un interfaccia Web che permette la gestione della rete fornendo funzionalit\u00e0 di: Registrazione degli apparati automatica Mappe geografiche per posizionamento Indoor e Outdoor VPN e certificati x509 Topologia di rete RADIUS manager: django-freeradius IP & subnet administration: django-ipam Sistemi di controllo Aggiornamento Firmware OpenWRT package , pacchetto installabile su OpenWRT per permettere la sincronizzazione con il controller","title":"2.1 OpenWisp"},{"location":"comp/#22-openwrt","text":"Il progetto OpenWrt \u00e8 un sistema operativo Linux destinato a dispositivi embedeed. Invece di provare a creare un singolo firmware statico, OpenWrt fornisce un filesystem completamente scrivibile con gestione dei pacchetti. Questo libera dalla selezione e dalla configurazione dell'applicazione fornite dal venditore e consente di personalizzare il dispositivo attraverso l'uso di pacchetti per adattarsi a qualsiasi applicazione. Per gli sviluppatori, OpenWrt \u00e8 il framework per creare un'applicazione senza dover creare un firmware completo al suo interno; per gli utenti ci\u00f2 significa la possibilit\u00e0 di personalizzazione completa, permettendo di adattarlo secondo le proprie esigenze. OpenWRT ad oggi \u00e8 supportato da oltre 1000 device. Consultando il sito del progetto \u00e8 possibile verificarne la compatibilit\u00e0 e la procedura per sostituire il firmware stock.","title":"2.2 OpenWRT"},{"location":"comp/#23-freeradius","text":"FreeRADIUS \u00e8 la pi\u00f9 popolare implementazione open-source del protocollo RADIUS. Permette l\u2019autenticazione, l\u2019autorizzazzione e l\u2019accounting. Nel nostro caso a stretto contatto con django-freeradius autorizzer\u00e0 la navigazione ad internet dopo essere passati dal nostro captive portal.","title":"2.3 FreeRADIUS"},{"location":"comp/#24-django-freeradius","text":"E\u2019 un\u2019interfaccia web per gestire il database FreeRADIUS basata su Django. Necessaria per integrare le funzionalit\u00e0 di FreeRADIUS per poter gestire l\u2019autorizzazione, la post autenticazione e l\u2019accounting tramite API RESTful. Inoltre in questo caso \u00e8 necessario per permettere la verifica tramite social grazie all\u2019integrazione del modulo django-allauth.","title":"2.4 Django-Freeradius"},{"location":"comp/#25-coovachilli","text":"CoovaChilli \u00e8 un controller ricco di funzionalit\u00e0 che fornisce la possibilit\u00e0 di attivare un Captive Portal cos\u00ec da garantire l'accesso tramite protocollo RADIUS o HTTP permettendo l'access provisioning e l'accounting. Questo controller \u00e8 fruibile come package per Openwrt oppure \u00e8 parte integrante del firmware CoovaAP. Questo package sommato a Freeradius e Django-freeradius permetter\u00e0 di raggiungere il nostro obbiettivo.","title":"2.5 CoovaChilli"},{"location":"howto/","text":"dn img[alt=ap1] { max-height:325px; } img[alt=ap2] { max-height:325px; } img[alt=ap3] { max-height:325px; } img[alt=wroam] { max-height:450px; }</p> 3.1 Server DNS: BIND9 Note Versione pfSense utilizzata durante la configurazione: 2.4.4 Versione BIND9 installata: 9.12 Si ringrazia il blog di RaffaeleChiatto per gli spunti La prima operazione da effettuare \u00e8 installare il package di BIND9 utilizzando il package manager di pfSense. System -> Package Manager quindi selezionare Bind e cliccare su Install L\u2019installazione durer\u00e0 qualche secondo e se tutto \u00e8 andato a buon fine dovremmo vedere il BIND sotto gli Installed Packages: Prima di procedere alla configurazione del BIND Server bisogna disattivare il DNS Forwarder e il DNS Resolver Andare quindi nel menu a tendina sotto Services e selezionare DNS Forwarder Togliamo la spunta a Enable DNS forwarder e cliccare su Save Effettuare la stessa procedura anche con il DNS Resolver Ritornare quindi al men\u00f9 Services e cliccare su BIND DNS Server Attivare il BIND spuntando Enable BIND DNS server. Selzionare l\u2019interfaccia sulla quale attivare il DNS (di solito la risoluzione DNS interna va attivata sull\u2019interfaccia di LAN) Nella sezione Logging Options abilitare i logs quindi selezionare l\u2019opzione di Default se si vuole avere il log di tutto altrimenti selezionare l\u2019opzione desiderata. Per quanto riguarda le altre opzioni abilitare solo il forwarding cosi da poter risolvere tutto ci\u00f2 che non \u00e8 censito nelle zone interne con dei DNS pubblici. NOTA BENE separare i DNS con un ; e inserire il ; anche alla fine dei DNS come mostrato nell\u2019immagine sovrastante A questo punto cliccare su Save per salvare la configurazione Tornare in alto nella pagina di configurazione e cliccare sul link Views quindi cliccare sul pulsante Add NOTA BENE la sezione ACLs \u00e8 stata saltata perch\u00e8 \u00e8 una sezione che permette di fare configurazioni avanzate bloccando la risoluzione DNS solo a determinati IP o subnet. Dare un nome alla Vista e una descrizione. Settare la Recursion a Yes NOTA BENE Una query ricorsiva si verifica quando il tuo server DNS viene interrogato per un dominio di cui attualmente non sa nulla, nel qual caso prover\u00e0 a risolvere l\u2019host dato eseguendo ulteriori query (ad es. Iniziando dai root server e risolvendo, o semplicemente passare la richiesta a un altro server DNS). Impostare su match-clients e su allow-recursion any come mostrato in figura sovrastante. Cliccare su Save per salvare le modifiche. Tornare in alto nella pagina di configurazione e cliccare sul link Views quindi cliccare sul pulsante Add Inserire il nome della zona interna e la descrizione Come Zone Type impostare Master Nel campo View selezionare InsideView creato in precedenza Passare alla sezione Zone Domain records quindi inseriamo tutti i record che vogliamo risolvere dalla nostra zona interna definita in precedenza Inserire nome e IP Andare al fondo della pagina verificare il file di configurazione quindi cliccare su Save per salvare le impostazioni A questo punto la configurazione del server BIND \u00e8 terminata Andiamo nel men\u00f9 Status -> Services Riavviamo il servizio named cliccando sul tasto a forma di freccia circolare !!! Attenzione! Per tutti i passaggi successivi assicurarsi che la risoluzione dei nomi avvenga correttamente su tutti gli host 3.2 Flash di OpenWRT Note la nostra rete \u00e8 caratterizzata da 5 Access Point Cisco Meraki MR18. Come da documentazione ufficiale, esistono in base alla versione firmware installata 3 metodi per il flashing di seguito esplicito il metodo C in quanto \u00e8 il nostro caso. Requisiti Router oppure DHCP Server Web server Adattatore UART Collegamento adattatore UART al Meraki MR18. Collegare all' MR18 a un router (con DHCP attivo) tenendolo scollegato Internet. Questo \u00e8 fondamentale per questo exploit. Tenere premuto il pulsante di reset sul MR18 per 10 secondi. Si dovrebbe vedere il led lampeggiare e poi spegnere. Una volta spento il LED, \u00e8 possibile interrompere la pressione sul pulsante di reset. In questo modo viene eseguito un ripristino di \"Livello 2\" e vengono rimosse tutte le configurazioni dal punto di accesso. Collegare l'adattatore UART dall' MR18 al PC Collegare il PC allo stesso router utilizzato da MR18. Quindi, ricordare l'indirizzo IP asseganto al PC. In questo esempio verr\u00e0 usato 192.168.1.102. Una volta avviato l' MR18, avviare un server HTTP (sulla porta 80) sul PC nella stessa directory del file del firmware. Avviare putty (su windows) oppure un accesso seriale utilizzando l\u2019adattatore. Una volta fatto l\u2019accesso, \u00e8 possibile caricare questa immagine nella partizione \"part2\" sul MR18. Questa operazione viene eseguita digitando il seguente comando: odm firmware part2 192.168.1.102:80/lede-ar71xx-nand-mr18-initramfs-kernel.bin Note Si noti che il comando precedente potrebbe andare in timeout, a seconda dello stato del router durante il processo di avvio. Se si verifica il timeout o non riesce, \u00e8 sufficiente attendere 60 secondi e riprovare. Normalmente il momento migliore per eseguire il comando \u00e8 quando il LED sul MR18 \u00e8 verde o lampeggiante arancione. Una volta completato, rimuovere l'alimentazione dal Meraki MR18. Dopo che l'alimentazione viene rimossa, nella sessione UART tenere premuto \"2\" sulla tastiera fino a quando non viene rimessa l'alimentazione. Questo dovrebbe ora avviare l'immagine initramfs appena caricata sul MR18. Scollegare il MR18 dal router e collegare direttamente il computer ad esso. Una volta collegato, si dovrebbe ottenere un IP dal MR18. Ora che il firmware \u00e8 stato caricato, aprire un browser sul computer e passare a http://192.168.1.1. Una volta effettuato l'accesso a LuCI, \u00e8 possibile caricare una versione pi\u00f9 aggiornata del firmware scaricandola dal sito ufficiale. Una volta caricato, il MR18 dovrebbe riavviarsi ed essere completamente in esecuzione OpenWrt/LEDE Installazione pacchetti e configurazioni aggiuntive Per abilitare l'HTTPS sull'interfaccia web: opkg install luci-ssl Installazione Coovachilli (per attivare il captive portal) opkg install coova-chilli Rimozione wpad-mini e Installazione di per abilitare il protocollo 802.11r opkg remove wpad-mini opkg install wpad Settaggio indirizzo ip Settaggio hostname con il relativo inserimento nella zona DNS Progetti tuttora in sviluppo Per le componenti elencate nei prossimi 3 paragrafi considerando che la comunit\u00e0 di OpenWisp allo stato attuale (a parte il controller) sono ancora in via sviluppo \u00e8 stato deciso di separarli installando ogni componente in una VM separata (Ubuntu Server 18.04.3) 3.3 Deploy OpenWISP Controller Documentazione Sito ufficiale GitHub - OpenWisp Controller (ansible) GitHub - OpenWisp Package Elenco progetti OpenWisp Per agevolare l'installazione del controller in produzione la comunit\u00e0 di OpenWisp ha deciso di utilizzare ansible, un software libero che consente di automatizzare le procedure di configurazione e gestione sui sistemi unix-like e Windows. Per l'installazione tramite ansible \u00e8 necessario definire due concetti chiave: \"Server di produzione\": Nel nostro caso la VM con Ubuntu Server 18.04, 192.168.3.100, openwisp.planet.bn \"Macchina locale\": ci si riferisce all'host che verr\u00e0 utilizzato per inviare l'installazione e le configurazioni al server di produzione Ansible \u00e8 uno strumento di gestione della configurazione che funziona collegandosi ai server di produzione tramite SSH, quindi \u00e8 necessario installarlo e configurarlo sulla computer che abbiamo definito \"Machina locale\": # Installazione di ansible sudo apt update sudo apt install git sudo apt install software-properties-common sudo apt-add-repository --yes --update ppa:ansible/ansible sudo apt install ansible # Installazione in ansible i ruoli per poter effettuare la installazione ansible-galaxy install openwisp.openwisp2 # Creo una cartella per poi inserire i file di configurazione mkdir ~/openwisp cd ~/openwisp touch playbook.yml touch hosts # Creazione della chiave per autenticarsi al server di produzione senza password ssh-keygen ssh-copy-id <user>@<FQDN> # Eseguire Ansible per iniziare l'installazione. # Sostituire <user> con l\u2019utente in uso sulla macchina di produzione # a cui gli si chieder\u00e0 di installare il controller ansible-playbook -i hosts playbook.yml -u <user> -k --become -K # playbook.yml - hosts: openwisp.planet.bn become: \"{{ become | default('yes') }}\" roles: - openwisp.openwisp2 vars: openwisp2_network_topology: true openwisp2_default_from_email: bunkernet@oratoriopandino.it # hosts [openwisp2] openwisp.planet.bn Accedere infine alla web gui e cambiare la password di default (admin - admin). Recuperare poi il codice organizzazione e completare i campi vuoti (necessario per i prossimi passaggi, Home \u203a Users and Organizations \u203a Organizations) ) Preparazione Access Point per la connessione Per cmpletare la sincronizzazione \u00e8 necessario accedere via SSH ad ogni Access Point che si desidera collegare. Installare il seguente pacchetto opkg install http://downloads.openwisp.io/openwisp-config/latest/openwisp-config-nossl_0.4.6a-1_all.ipk Modificare il file /etc/config/openwisp config controller 'http' option url 'https://openwisp.planet.bn' option shared_secret \u2018\u2019 option verify_ssl '0' option mac_interface 'eth0' option uuid '' option key '' Tale configurazione indica i parametri di connessione al controller che per poter rimanere autenticato deve ricevere tali configurazioni: url : FQDN del controller shared_secret : chiave del controller verify_ssl : 1 se \u00e8 presente un certificato firmato, 0 se il certificato \u00e8 self-signed mac_interface : nome dell\u2019interfaccia dell\u2019AP da cui lo script registrazione prelever\u00e0 il mac address che verr\u00e0 utilizzato per generare automaticamente le chiavi univoche uuid,key Infine, aprire due shell e inserire rispettivamente # Per monitorare se la registrazione al controller avviene correttamente: logread -f | grep openwisp # Per avviare il demone di OpenWISP: /etc/init.d/openwisp_config start 3.4 Installazione django-freeradius Documentazione ufficiale ReadTheDocs Note Versione di python utilizzata: 3.6.5 E' verificabile digitando python3 --version Con l'avvento di Python3 \u00e8 diventato fortemente consigliato di fare uso dei Virtual Environment. Virtual Environment sta per Ambiente Virtuale, e si tratta di una best practice che ci permette di creare degli spazi indipendenti dal resto del sistema in cui \u00e8 possibile testare e lavorare con Python e pip. La grande popolarit\u00e0 degli Ambienti Virtuali, \u00e8 dovuta al fatto che ci consentono di lavorare e sperimentare con pi\u00f9 progetti contemporaneamente nonostante magari questi utilizzino una versione diversa degli stessi moduli. Inoltre ci permettono di installare moduli con pip senza i privilegi di root, con tutti i vantaggi in termini di sicurezza che questo comporta. Di seguito quindi la preparazione di un ambiente virtuale con le relative librerie necessarie. sudo apt install python3-pip sudo apt install python3-venv sudo apt install sqlite3 libsqlite3-dev sudo apt install libmysqlclient-dev mkdir environments cd environments python3 -m venv radius_env source radius_env/bin/activate (radius_env) bobby@bobby:~/environments$ pip install django Creato l'ambiente, installato Django, si pu\u00f2 procedere all'installazione del database di cui django-freeradius ne far\u00e0 uso. sudo apt install postgresql sudo apt install postgresql-server-dev-10 sudo -i -u postgres createuser -S djangoradius -P createdb jradius_db -O djangoradius Creazione del progetto e installazione librerie necessarie django-admin startproject djangoradius cd djangoradius pip install psycopg2 pip install https://github.com/openwisp/django-freeradius/tarball/master pip install --upgrade http://github.com/openwisp/openwisp-utils/tarball/master pip install wheel pip install django-allauth Applicazione delle modifiche e creazione utente superuser ./manage.py migrate ./manage.py createsuperuser Modificare il file settings.py come in seguito: ALLOWED_HOSTS = ['192.168.3.102:8000'] INSTALLED_APPS = [ #OtherApps 'django_freeradius', 'django_filters', ] DJANGO_FREERADIUS_API_TOKEN = '165f9a790787fc38e5cc12c1640db2300648d9a2' DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'jradius_db', 'USER': 'djangoradius', 'PASSWORD': 'pwddb', 'HOST': '127.0.0.1', 'PORT': '5432' }, } urls.py from django.conf.urls import include Installato e configurato il necessario, \u00e8 possibile avviare il server python manage.py runserver 192.168.1.56:8000 3.5 Preparazione del Captive Portal Affinch\u00e8 django-freeradius autorizzi gli utenti a navigare \u00e8 necessario che comunichi con le rispettive API dei social network e per fare ci\u00f2 \u00e8 richiesto che django utilizzi una connessione HTTPS. Un qualsiasi progetto django di default utilizza una connessione HTTP, di seguito la procedura per convertirlo in HTTPS (Fonte GitHub ) sudo apt install stunnel Spostarsi nella cartella del progetto in cui risiede il file manage.py cd /home/openwisp/djangoRadius/djangoradius mkdir stunnel cd stunnel Creare la chiave openssl genrsa 1024 > stunnel.key openssl req -new -x509 -nodes -sha1 -days 365 -key stunnel.key > stunnel.cert cat stunnel.key stunnel.cert > stunnel.pem Creare un file di nome dev_https con contenuto: pid= cert = stunnel.pem sslVersion = SSLv3 foreground = yes output = stunnel.log [https] accept=8000 connect=8001 TIMEOUTclose=1 Ritornare nella cartella del manage.py e creare un file di nome runserver con i permessi di esecuzione stunnel4 stunnel/dev_https & python manage.py runserver& chmod a+x runserver Installazione di django-allauth Il social login \u00e8 supportato generando un token temporaneo dopo che l'utente ha effettuato un login corretto, l'utente \u00e8 poi reindirizzato alla pagina di captive portal con 2 parametri: username e token. La pagina di captive portal riconosce questi due parametri e lo username \u00e8 ovviamente usato per il campo username mentre il token per il campo password. Le API REST interne di django-freeradius riconosceranno il token e lo autorizzeranno questo tipo di implementazione permette di implementare qualsiasi social login che gi\u00e0 supporta il protocollo RADIUS perch\u00e8 \u00e8 totalmente trasparente per esso. Di seguito la procedura per integrare il social login: Questa procedura prende come esempio l'integrazione con facebook pip install django-allauth Assicurarsi che il file settings.py sia come il seguente INSTALLED_APPS = [ # ... other apps .. # apps needed for social login 'rest_framework.authtoken', 'django.contrib.sites', 'allauth', 'allauth.account', 'allauth.socialaccount', # showing facebook as an example # to configure social login with other social networks # refer to the django-allauth documentation 'allauth.socialaccount.providers.facebook', ] SITE_ID = 1 # showing facebook as an example # to configure social login with other social networks # refer to the django-allauth documentation SOCIALACCOUNT_PROVIDERS = { 'facebook': { 'METHOD': 'oauth2', 'SCOPE': ['email', 'public_profile'], 'AUTH_PARAMS': {'auth_type': 'reauthenticate'}, 'INIT_PARAMS': {'cookie': True}, 'FIELDS': [ 'id', 'email', 'name', 'first_name', 'last_name', 'verified', ], 'VERIFIED_EMAIL': True, } } Assicurarsi che il file urls.py contenga anche allauth.urls: urlpatterns = [ # .. other urls ... url(r'^accounts/', include('allauth.urls')), ] Infine come spiegato in questo video , la procedura per abilitare e configurare un account facebook developer e collegarlo a django-freeradius. Esempio di Captive Page <a href=\"https://cportal.planet.bn:8000/accounts/facebook/login/?next=%2Ffreeradius%2Fsocial-login%2F%3Fcp%3Dhttps%3A%2F%2Fcportal.planet.bn%2F%26last%3D\" class=\"button\">Log in with Facebook </a> 3.6 Installazione FreeRADIUS 3 In questa parte viene spiegato come installare e configurare freeradius3 per renderlo funzionante con django- freeradius. Note Questa procedura \u00e8 stata scritta per essere eseguita su Ubuntu 18.04, per altre distribuzioni linux il nome dei package e i percorsi potrebbero variare. Per ulteriori chiarimenti consultare la documentazione ufficiale Prima di tutto, diventare root sudo -s Installazione pacchetti necessari e configurazione del database (In questo caso, PostgreSQL) apt update apt install freeradius freeradius-rest apt install freeradius-postgresql sudo apt install postgresql sudo -i -u postgres createuser -S freeradius -P createdb radius -O freeradius exit Attivazione moduli necessari ln -s /etc/freeradius/mods-available/sql /etc/freeradius/mods-enabled/sql ln -s /etc/freeradius/mods-available/rest /etc/freeradius/mods-enabled/rest Configurazione del modulo sql Una volta configurato correttamente un SQL server \u00e8 necessario configurare il modulo sql con il driver da utilizzare, il dialect, indirizzo del server, username, password e il nome del database da creare. Quindi accedere al file /etc/freeradius/3.0/mods-available/sql e cercare: driver = \"rlm_sql_postgresql\" dialect = \"postgresql\" # Connection info: server = \"localhost\" port = 5432 login = \"<user>\" password = \"<password>\" radius_db = \"radius\" Configurazione del modulo sqlcounter Il modulo sqlcounter \u00e8 usato per forzare il limite di sessione. Accedere al file etc/freeradius/mods-available/3.0/sqlcounter e modificarlo come segue: # The dailycounter is included by default in the freeradius conf sqlcounter dailycounter { sql_module_instance = sql dialect = ${modules.sql.dialect} counter_name = Daily-Session-Time check_name = Max-Daily-Session reply_name = Session-Timeout key = User-Name reset = daily $INCLUDE ${modconfdir}/sql/counter/${dialect}/${.:instance}.conf } # The noresetcounter is included by default in the freeradius conf sqlcounter noresetcounter { sql_module_instance = sql dialect = ${modules.sql.dialect} counter_name = Max-All-Session-Time check_name = Max-All-Session key = User-Name reset = never $INCLUDE ${modconfdir}/sql/counter/${dialect}/${.:instance}.conf } # The dailybandwidthcounter is added for django-freeradius sqlcounter dailybandwidthcounter { counter_name = Max-Daily-Session-Traffic check_name = Max-Daily-Session-Traffic sql_module_instance = sql key = 'User-Name' reset = daily query = \"SELECT SUM(acctinputoctets + acctoutputoctets) \\ FROM radacct \\ WHERE UserName='%{${key}}' \\ AND UNIX_TIMESTAMP(acctstarttime) + acctsessiontime > '%%b'\" } Una volta configurato il file come sopra \u00e8 necessario attivare il modulo con una procedura particolare in quanto a causa di un bug non \u00e8 possibile attivare tale modulo come tutti gli altri (es. sql e rest) accedere a /etc/freeradius/3.0/radiusd.conf e aggiungere come segue sqlcounter modules { # .. $INCLUDE mods-enabled $INCLUDE mods-available/sqlcounter # .. } Configurazione del modulo REST modificare /etc/freeradius/3.0/mods-enabled/rest sostituendo <url> con l'url usato dal proprio progetto django connect_uri = \"http://127.0.0.1:8000\" authorize { uri = \"${..connect_uri}/api/v1/authorize/\" method = 'post' body = 'json' data = '{\"username\": \"%{User-Name}\", \"password\": \"%{User-Password}\"}' tls = ${..tls} } # this section can be left empty authenticate {} post-auth { uri = \"${..connect_uri}/api/v1/postauth/\" method = 'post' body = 'json' data = '{\"username\": \"%{User-Name}\", \"password\": \"%{User-Password}\", \"reply\": \"%{reply:Packet- Type}\", \"called_station_id\": \"%{Called-Station-ID}\", \"calling_station_id\": \"%{Calling-Station-ID}\"}' tls = ${..tls} } accounting { uri = \"${..connect_uri}/api/v1/accounting/\" method = 'post' body = 'json' data = '{\"status_type\": \"%{Acct-Status-Type}\", \"session_id\": \"%{Acct-Session-Id}\", \"unique_id\": \"% {Acct-Unique-Session-Id}\", \"username\": \"%{User-Name}\", \"realm\": \"%{Realm}\", \"nas_ip_address\": \"%{NAS-IP- Address}\", \"nas_port_id\": \"%{NAS-Port}\", \"nas_port_type\": \"%{NAS-Port-Type}\", \"session_time\": \"%{Acct- Session-Time}\", \"authentication\": \"%{Acct-Authentic}\", \"input_octets\": \"%{Acct-Input-Octets}\", \"output_octets\": \"%{Acct-Output-Octets}\", \"called_station_id\": \"%{Called-Station-Id}\", \"calling_station_id\": \"%{Calling-Station-Id}\", \"terminate_cause\": \"%{Acct-Terminate-Cause}\", \"service_type\": \"%{Service-Type}\", \"framed_protocol\": \"%{Framed-Protocol}\", \"framed_ip_address\": \"% {Framed-IP-Address}\"}' tls = ${..tls} } Configurazione del sito Cinfigura le sezioni authorize , authenticate e postauth come segue sostituendo con il valore della variabile DJANGO_FREERADIUS_API_TOKEN inserita nel file settings.py Aprire quindi /etc/freeradius/sites-enabled/default api_token_header = \"Authorization: Bearer <api_token>\" authorize { update control { &REST-HTTP-Header += \"${...api_token_header}\" } rest sql dailycounter noresetcounter dailybandwidthcounter } # this section can be left empty authenticate {} post-auth { update control { &REST-HTTP-Header += \"${...api_token_header}\" } rest Post-Auth-Type REJECT { update control { &REST-HTTP-Header += \"${....api_token_header}\" } rest } } accounting { update control { &REST-HTTP-Header += \"${...api_token_header}\" } rest } assicurarsi che nella sezione preacct ci sia acct_unique preacct { # ... acct_unique # ... } Riavviare freeradius per rendere effettiva la nuova configurazione service freeradius restart # oppure systemctl restart freeradius In caso di errori avvia freeradius in modalit\u00e0 debug. freeradius -X # oppure freeradius -Xx","title":"3. How to"},{"location":"howto/#31-server-dns-bind9","text":"Note Versione pfSense utilizzata durante la configurazione: 2.4.4 Versione BIND9 installata: 9.12 Si ringrazia il blog di RaffaeleChiatto per gli spunti La prima operazione da effettuare \u00e8 installare il package di BIND9 utilizzando il package manager di pfSense. System -> Package Manager quindi selezionare Bind e cliccare su Install L\u2019installazione durer\u00e0 qualche secondo e se tutto \u00e8 andato a buon fine dovremmo vedere il BIND sotto gli Installed Packages: Prima di procedere alla configurazione del BIND Server bisogna disattivare il DNS Forwarder e il DNS Resolver Andare quindi nel menu a tendina sotto Services e selezionare DNS Forwarder Togliamo la spunta a Enable DNS forwarder e cliccare su Save Effettuare la stessa procedura anche con il DNS Resolver Ritornare quindi al men\u00f9 Services e cliccare su BIND DNS Server Attivare il BIND spuntando Enable BIND DNS server. Selzionare l\u2019interfaccia sulla quale attivare il DNS (di solito la risoluzione DNS interna va attivata sull\u2019interfaccia di LAN) Nella sezione Logging Options abilitare i logs quindi selezionare l\u2019opzione di Default se si vuole avere il log di tutto altrimenti selezionare l\u2019opzione desiderata. Per quanto riguarda le altre opzioni abilitare solo il forwarding cosi da poter risolvere tutto ci\u00f2 che non \u00e8 censito nelle zone interne con dei DNS pubblici. NOTA BENE separare i DNS con un ; e inserire il ; anche alla fine dei DNS come mostrato nell\u2019immagine sovrastante A questo punto cliccare su Save per salvare la configurazione Tornare in alto nella pagina di configurazione e cliccare sul link Views quindi cliccare sul pulsante Add NOTA BENE la sezione ACLs \u00e8 stata saltata perch\u00e8 \u00e8 una sezione che permette di fare configurazioni avanzate bloccando la risoluzione DNS solo a determinati IP o subnet. Dare un nome alla Vista e una descrizione. Settare la Recursion a Yes NOTA BENE Una query ricorsiva si verifica quando il tuo server DNS viene interrogato per un dominio di cui attualmente non sa nulla, nel qual caso prover\u00e0 a risolvere l\u2019host dato eseguendo ulteriori query (ad es. Iniziando dai root server e risolvendo, o semplicemente passare la richiesta a un altro server DNS). Impostare su match-clients e su allow-recursion any come mostrato in figura sovrastante. Cliccare su Save per salvare le modifiche. Tornare in alto nella pagina di configurazione e cliccare sul link Views quindi cliccare sul pulsante Add Inserire il nome della zona interna e la descrizione Come Zone Type impostare Master Nel campo View selezionare InsideView creato in precedenza Passare alla sezione Zone Domain records quindi inseriamo tutti i record che vogliamo risolvere dalla nostra zona interna definita in precedenza Inserire nome e IP Andare al fondo della pagina verificare il file di configurazione quindi cliccare su Save per salvare le impostazioni A questo punto la configurazione del server BIND \u00e8 terminata Andiamo nel men\u00f9 Status -> Services Riavviamo il servizio named cliccando sul tasto a forma di freccia circolare !!! Attenzione! Per tutti i passaggi successivi assicurarsi che la risoluzione dei nomi avvenga correttamente su tutti gli host","title":"3.1 Server DNS: BIND9"},{"location":"howto/#32-flash-di-openwrt","text":"Note la nostra rete \u00e8 caratterizzata da 5 Access Point Cisco Meraki MR18. Come da documentazione ufficiale, esistono in base alla versione firmware installata 3 metodi per il flashing di seguito esplicito il metodo C in quanto \u00e8 il nostro caso. Requisiti Router oppure DHCP Server Web server Adattatore UART Collegamento adattatore UART al Meraki MR18. Collegare all' MR18 a un router (con DHCP attivo) tenendolo scollegato Internet. Questo \u00e8 fondamentale per questo exploit. Tenere premuto il pulsante di reset sul MR18 per 10 secondi. Si dovrebbe vedere il led lampeggiare e poi spegnere. Una volta spento il LED, \u00e8 possibile interrompere la pressione sul pulsante di reset. In questo modo viene eseguito un ripristino di \"Livello 2\" e vengono rimosse tutte le configurazioni dal punto di accesso. Collegare l'adattatore UART dall' MR18 al PC Collegare il PC allo stesso router utilizzato da MR18. Quindi, ricordare l'indirizzo IP asseganto al PC. In questo esempio verr\u00e0 usato 192.168.1.102. Una volta avviato l' MR18, avviare un server HTTP (sulla porta 80) sul PC nella stessa directory del file del firmware. Avviare putty (su windows) oppure un accesso seriale utilizzando l\u2019adattatore. Una volta fatto l\u2019accesso, \u00e8 possibile caricare questa immagine nella partizione \"part2\" sul MR18. Questa operazione viene eseguita digitando il seguente comando: odm firmware part2 192.168.1.102:80/lede-ar71xx-nand-mr18-initramfs-kernel.bin Note Si noti che il comando precedente potrebbe andare in timeout, a seconda dello stato del router durante il processo di avvio. Se si verifica il timeout o non riesce, \u00e8 sufficiente attendere 60 secondi e riprovare. Normalmente il momento migliore per eseguire il comando \u00e8 quando il LED sul MR18 \u00e8 verde o lampeggiante arancione. Una volta completato, rimuovere l'alimentazione dal Meraki MR18. Dopo che l'alimentazione viene rimossa, nella sessione UART tenere premuto \"2\" sulla tastiera fino a quando non viene rimessa l'alimentazione. Questo dovrebbe ora avviare l'immagine initramfs appena caricata sul MR18. Scollegare il MR18 dal router e collegare direttamente il computer ad esso. Una volta collegato, si dovrebbe ottenere un IP dal MR18. Ora che il firmware \u00e8 stato caricato, aprire un browser sul computer e passare a http://192.168.1.1. Una volta effettuato l'accesso a LuCI, \u00e8 possibile caricare una versione pi\u00f9 aggiornata del firmware scaricandola dal sito ufficiale. Una volta caricato, il MR18 dovrebbe riavviarsi ed essere completamente in esecuzione OpenWrt/LEDE","title":"3.2 Flash di OpenWRT"},{"location":"howto/#33-deploy-openwisp-controller","text":"Documentazione Sito ufficiale GitHub - OpenWisp Controller (ansible) GitHub - OpenWisp Package Elenco progetti OpenWisp Per agevolare l'installazione del controller in produzione la comunit\u00e0 di OpenWisp ha deciso di utilizzare ansible, un software libero che consente di automatizzare le procedure di configurazione e gestione sui sistemi unix-like e Windows. Per l'installazione tramite ansible \u00e8 necessario definire due concetti chiave: \"Server di produzione\": Nel nostro caso la VM con Ubuntu Server 18.04, 192.168.3.100, openwisp.planet.bn \"Macchina locale\": ci si riferisce all'host che verr\u00e0 utilizzato per inviare l'installazione e le configurazioni al server di produzione Ansible \u00e8 uno strumento di gestione della configurazione che funziona collegandosi ai server di produzione tramite SSH, quindi \u00e8 necessario installarlo e configurarlo sulla computer che abbiamo definito \"Machina locale\": # Installazione di ansible sudo apt update sudo apt install git sudo apt install software-properties-common sudo apt-add-repository --yes --update ppa:ansible/ansible sudo apt install ansible # Installazione in ansible i ruoli per poter effettuare la installazione ansible-galaxy install openwisp.openwisp2 # Creo una cartella per poi inserire i file di configurazione mkdir ~/openwisp cd ~/openwisp touch playbook.yml touch hosts # Creazione della chiave per autenticarsi al server di produzione senza password ssh-keygen ssh-copy-id <user>@<FQDN> # Eseguire Ansible per iniziare l'installazione. # Sostituire <user> con l\u2019utente in uso sulla macchina di produzione # a cui gli si chieder\u00e0 di installare il controller ansible-playbook -i hosts playbook.yml -u <user> -k --become -K # playbook.yml - hosts: openwisp.planet.bn become: \"{{ become | default('yes') }}\" roles: - openwisp.openwisp2 vars: openwisp2_network_topology: true openwisp2_default_from_email: bunkernet@oratoriopandino.it # hosts [openwisp2] openwisp.planet.bn Accedere infine alla web gui e cambiare la password di default (admin - admin). Recuperare poi il codice organizzazione e completare i campi vuoti (necessario per i prossimi passaggi, Home \u203a Users and Organizations \u203a Organizations) )","title":"3.3 Deploy OpenWISP Controller"},{"location":"howto/#34-installazione-django-freeradius","text":"Documentazione ufficiale ReadTheDocs Note Versione di python utilizzata: 3.6.5 E' verificabile digitando python3 --version Con l'avvento di Python3 \u00e8 diventato fortemente consigliato di fare uso dei Virtual Environment. Virtual Environment sta per Ambiente Virtuale, e si tratta di una best practice che ci permette di creare degli spazi indipendenti dal resto del sistema in cui \u00e8 possibile testare e lavorare con Python e pip. La grande popolarit\u00e0 degli Ambienti Virtuali, \u00e8 dovuta al fatto che ci consentono di lavorare e sperimentare con pi\u00f9 progetti contemporaneamente nonostante magari questi utilizzino una versione diversa degli stessi moduli. Inoltre ci permettono di installare moduli con pip senza i privilegi di root, con tutti i vantaggi in termini di sicurezza che questo comporta. Di seguito quindi la preparazione di un ambiente virtuale con le relative librerie necessarie. sudo apt install python3-pip sudo apt install python3-venv sudo apt install sqlite3 libsqlite3-dev sudo apt install libmysqlclient-dev mkdir environments cd environments python3 -m venv radius_env source radius_env/bin/activate (radius_env) bobby@bobby:~/environments$ pip install django Creato l'ambiente, installato Django, si pu\u00f2 procedere all'installazione del database di cui django-freeradius ne far\u00e0 uso. sudo apt install postgresql sudo apt install postgresql-server-dev-10 sudo -i -u postgres createuser -S djangoradius -P createdb jradius_db -O djangoradius Creazione del progetto e installazione librerie necessarie django-admin startproject djangoradius cd djangoradius pip install psycopg2 pip install https://github.com/openwisp/django-freeradius/tarball/master pip install --upgrade http://github.com/openwisp/openwisp-utils/tarball/master pip install wheel pip install django-allauth Applicazione delle modifiche e creazione utente superuser ./manage.py migrate ./manage.py createsuperuser Modificare il file settings.py come in seguito: ALLOWED_HOSTS = ['192.168.3.102:8000'] INSTALLED_APPS = [ #OtherApps 'django_freeradius', 'django_filters', ] DJANGO_FREERADIUS_API_TOKEN = '165f9a790787fc38e5cc12c1640db2300648d9a2' DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'jradius_db', 'USER': 'djangoradius', 'PASSWORD': 'pwddb', 'HOST': '127.0.0.1', 'PORT': '5432' }, } urls.py from django.conf.urls import include Installato e configurato il necessario, \u00e8 possibile avviare il server python manage.py runserver 192.168.1.56:8000","title":"3.4 Installazione django-freeradius"},{"location":"howto/#35-preparazione-del-captive-portal","text":"Affinch\u00e8 django-freeradius autorizzi gli utenti a navigare \u00e8 necessario che comunichi con le rispettive API dei social network e per fare ci\u00f2 \u00e8 richiesto che django utilizzi una connessione HTTPS. Un qualsiasi progetto django di default utilizza una connessione HTTP, di seguito la procedura per convertirlo in HTTPS (Fonte GitHub ) sudo apt install stunnel Spostarsi nella cartella del progetto in cui risiede il file manage.py cd /home/openwisp/djangoRadius/djangoradius mkdir stunnel cd stunnel Creare la chiave openssl genrsa 1024 > stunnel.key openssl req -new -x509 -nodes -sha1 -days 365 -key stunnel.key > stunnel.cert cat stunnel.key stunnel.cert > stunnel.pem Creare un file di nome dev_https con contenuto: pid= cert = stunnel.pem sslVersion = SSLv3 foreground = yes output = stunnel.log [https] accept=8000 connect=8001 TIMEOUTclose=1 Ritornare nella cartella del manage.py e creare un file di nome runserver con i permessi di esecuzione stunnel4 stunnel/dev_https & python manage.py runserver& chmod a+x runserver Installazione di django-allauth Il social login \u00e8 supportato generando un token temporaneo dopo che l'utente ha effettuato un login corretto, l'utente \u00e8 poi reindirizzato alla pagina di captive portal con 2 parametri: username e token. La pagina di captive portal riconosce questi due parametri e lo username \u00e8 ovviamente usato per il campo username mentre il token per il campo password. Le API REST interne di django-freeradius riconosceranno il token e lo autorizzeranno questo tipo di implementazione permette di implementare qualsiasi social login che gi\u00e0 supporta il protocollo RADIUS perch\u00e8 \u00e8 totalmente trasparente per esso. Di seguito la procedura per integrare il social login: Questa procedura prende come esempio l'integrazione con facebook pip install django-allauth Assicurarsi che il file settings.py sia come il seguente INSTALLED_APPS = [ # ... other apps .. # apps needed for social login 'rest_framework.authtoken', 'django.contrib.sites', 'allauth', 'allauth.account', 'allauth.socialaccount', # showing facebook as an example # to configure social login with other social networks # refer to the django-allauth documentation 'allauth.socialaccount.providers.facebook', ] SITE_ID = 1 # showing facebook as an example # to configure social login with other social networks # refer to the django-allauth documentation SOCIALACCOUNT_PROVIDERS = { 'facebook': { 'METHOD': 'oauth2', 'SCOPE': ['email', 'public_profile'], 'AUTH_PARAMS': {'auth_type': 'reauthenticate'}, 'INIT_PARAMS': {'cookie': True}, 'FIELDS': [ 'id', 'email', 'name', 'first_name', 'last_name', 'verified', ], 'VERIFIED_EMAIL': True, } } Assicurarsi che il file urls.py contenga anche allauth.urls: urlpatterns = [ # .. other urls ... url(r'^accounts/', include('allauth.urls')), ] Infine come spiegato in questo video , la procedura per abilitare e configurare un account facebook developer e collegarlo a django-freeradius. Esempio di Captive Page <a href=\"https://cportal.planet.bn:8000/accounts/facebook/login/?next=%2Ffreeradius%2Fsocial-login%2F%3Fcp%3Dhttps%3A%2F%2Fcportal.planet.bn%2F%26last%3D\" class=\"button\">Log in with Facebook </a>","title":"3.5 Preparazione del Captive Portal"},{"location":"howto/#36-installazione-freeradius-3","text":"In questa parte viene spiegato come installare e configurare freeradius3 per renderlo funzionante con django- freeradius. Note Questa procedura \u00e8 stata scritta per essere eseguita su Ubuntu 18.04, per altre distribuzioni linux il nome dei package e i percorsi potrebbero variare. Per ulteriori chiarimenti consultare la documentazione ufficiale Prima di tutto, diventare root sudo -s Installazione pacchetti necessari e configurazione del database (In questo caso, PostgreSQL) apt update apt install freeradius freeradius-rest apt install freeradius-postgresql sudo apt install postgresql sudo -i -u postgres createuser -S freeradius -P createdb radius -O freeradius exit Attivazione moduli necessari ln -s /etc/freeradius/mods-available/sql /etc/freeradius/mods-enabled/sql ln -s /etc/freeradius/mods-available/rest /etc/freeradius/mods-enabled/rest Configurazione del modulo sql Una volta configurato correttamente un SQL server \u00e8 necessario configurare il modulo sql con il driver da utilizzare, il dialect, indirizzo del server, username, password e il nome del database da creare. Quindi accedere al file /etc/freeradius/3.0/mods-available/sql e cercare: driver = \"rlm_sql_postgresql\" dialect = \"postgresql\" # Connection info: server = \"localhost\" port = 5432 login = \"<user>\" password = \"<password>\" radius_db = \"radius\" Configurazione del modulo sqlcounter Il modulo sqlcounter \u00e8 usato per forzare il limite di sessione. Accedere al file etc/freeradius/mods-available/3.0/sqlcounter e modificarlo come segue: # The dailycounter is included by default in the freeradius conf sqlcounter dailycounter { sql_module_instance = sql dialect = ${modules.sql.dialect} counter_name = Daily-Session-Time check_name = Max-Daily-Session reply_name = Session-Timeout key = User-Name reset = daily $INCLUDE ${modconfdir}/sql/counter/${dialect}/${.:instance}.conf } # The noresetcounter is included by default in the freeradius conf sqlcounter noresetcounter { sql_module_instance = sql dialect = ${modules.sql.dialect} counter_name = Max-All-Session-Time check_name = Max-All-Session key = User-Name reset = never $INCLUDE ${modconfdir}/sql/counter/${dialect}/${.:instance}.conf } # The dailybandwidthcounter is added for django-freeradius sqlcounter dailybandwidthcounter { counter_name = Max-Daily-Session-Traffic check_name = Max-Daily-Session-Traffic sql_module_instance = sql key = 'User-Name' reset = daily query = \"SELECT SUM(acctinputoctets + acctoutputoctets) \\ FROM radacct \\ WHERE UserName='%{${key}}' \\ AND UNIX_TIMESTAMP(acctstarttime) + acctsessiontime > '%%b'\" } Una volta configurato il file come sopra \u00e8 necessario attivare il modulo con una procedura particolare in quanto a causa di un bug non \u00e8 possibile attivare tale modulo come tutti gli altri (es. sql e rest) accedere a /etc/freeradius/3.0/radiusd.conf e aggiungere come segue sqlcounter modules { # .. $INCLUDE mods-enabled $INCLUDE mods-available/sqlcounter # .. } Configurazione del modulo REST modificare /etc/freeradius/3.0/mods-enabled/rest sostituendo <url> con l'url usato dal proprio progetto django connect_uri = \"http://127.0.0.1:8000\" authorize { uri = \"${..connect_uri}/api/v1/authorize/\" method = 'post' body = 'json' data = '{\"username\": \"%{User-Name}\", \"password\": \"%{User-Password}\"}' tls = ${..tls} } # this section can be left empty authenticate {} post-auth { uri = \"${..connect_uri}/api/v1/postauth/\" method = 'post' body = 'json' data = '{\"username\": \"%{User-Name}\", \"password\": \"%{User-Password}\", \"reply\": \"%{reply:Packet- Type}\", \"called_station_id\": \"%{Called-Station-ID}\", \"calling_station_id\": \"%{Calling-Station-ID}\"}' tls = ${..tls} } accounting { uri = \"${..connect_uri}/api/v1/accounting/\" method = 'post' body = 'json' data = '{\"status_type\": \"%{Acct-Status-Type}\", \"session_id\": \"%{Acct-Session-Id}\", \"unique_id\": \"% {Acct-Unique-Session-Id}\", \"username\": \"%{User-Name}\", \"realm\": \"%{Realm}\", \"nas_ip_address\": \"%{NAS-IP- Address}\", \"nas_port_id\": \"%{NAS-Port}\", \"nas_port_type\": \"%{NAS-Port-Type}\", \"session_time\": \"%{Acct- Session-Time}\", \"authentication\": \"%{Acct-Authentic}\", \"input_octets\": \"%{Acct-Input-Octets}\", \"output_octets\": \"%{Acct-Output-Octets}\", \"called_station_id\": \"%{Called-Station-Id}\", \"calling_station_id\": \"%{Calling-Station-Id}\", \"terminate_cause\": \"%{Acct-Terminate-Cause}\", \"service_type\": \"%{Service-Type}\", \"framed_protocol\": \"%{Framed-Protocol}\", \"framed_ip_address\": \"% {Framed-IP-Address}\"}' tls = ${..tls} } Configurazione del sito Cinfigura le sezioni authorize , authenticate e postauth come segue sostituendo con il valore della variabile DJANGO_FREERADIUS_API_TOKEN inserita nel file settings.py Aprire quindi /etc/freeradius/sites-enabled/default api_token_header = \"Authorization: Bearer <api_token>\" authorize { update control { &REST-HTTP-Header += \"${...api_token_header}\" } rest sql dailycounter noresetcounter dailybandwidthcounter } # this section can be left empty authenticate {} post-auth { update control { &REST-HTTP-Header += \"${...api_token_header}\" } rest Post-Auth-Type REJECT { update control { &REST-HTTP-Header += \"${....api_token_header}\" } rest } } accounting { update control { &REST-HTTP-Header += \"${...api_token_header}\" } rest } assicurarsi che nella sezione preacct ci sia acct_unique preacct { # ... acct_unique # ... } Riavviare freeradius per rendere effettiva la nuova configurazione service freeradius restart # oppure systemctl restart freeradius In caso di errori avvia freeradius in modalit\u00e0 debug. freeradius -X # oppure freeradius -Xx","title":"3.6 Installazione FreeRADIUS 3"},{"location":"intro/","text":"Introduzione Con questo elaborato ho scelto di recuperare un progetto, intrapreso in ambito extrascolastico ormai diversi anni fa in un ambiente a me molto caro quale l\u2019Oratorio. Tale progetto, \u00e8 stato avviato (utilizzando mezzi e sistemi informatici) col fine di risolvere problematiche riscontrate nella quotidianit\u00e0. Diverse sono le tematiche affrontate, sviluppate e in attesa di essere attuate ma qui si focalizzer\u00e0 l\u2019attenzione su tutto l\u2019aspetto riguardante l\u2019accesso alla rete tramite wireless . In un primo momento \u00e8 stata fatta un\u2019analisi sui possibili stakeholder che ne faranno uso, poi sulla modalit\u00e0 di utilizzo e infine un\u2019analisi economica per valutare sulla base delle esigenze a quali spese saremmo andati incontro Dall\u2019analisi \u00e8 emerso che le tipologie di accesso saranno due: una per l\u2019amministrazione (SSID: Amministrazione OSL) quindi un accesso completo alla rete e ai servizi mentre un\u2019altra pubblica , (SSID Wi-Fi Zone Oratorio Pandino) un accesso da rendere disponibile a tutti i fruitori dell\u2019Oratorio con l\u2019attenzione di garantire un solo accesso ad Internet e controllato. Per la rete di amministrazione \u00e8 stato pensato un accesso tramite chiave con protocollo WPA2-PSK e cifratura TKIP + CCMP mentre per la Wi-Fi Zone pubblica un accesso tramite un Captive Portal utilizzando i principali social network del momento: Facebook, Twitter, Instagram e Google. Considerando le modeste disponibilit\u00e0 economiche per garantire tutto ci\u00f2 \u00e8 stato deciso di adottare tecnologie open source, per sua natura quindi, gratuite.","title":"1. Introduzone"}]}